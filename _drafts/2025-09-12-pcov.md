---
layout: post
title:  "Genome Assembly with Perfect Coverage"
date:   2025-07-18
---

![circular_string.png](../assets/circular_string.png)

A circular DNA string

[This](https://rosalind.info/problems/pcov/) problem asks:

> **Given**: A collection of (error-free) DNA _k_-mers (_k_â‰¤50) taken from the same strand of a circular chromosome. In this dataset, all k-mers from this strand of the chromosome are present, and their de Bruijn graph consists of exactly one simple cycle.

> **Return**: A cyclic superstring of minimal length containing the reads (thus corresponding to a candidate cyclic chromosome).

<!--break-->

# References
1. [Perfect coverage](https://rosalind.info/glossary/perfect-coverage/)
2. [Circular string](https://rosalind.info/glossary/circular-string/)
3. [de Bruijn graph](https://rosalind.info/glossary/de-bruijn-graph/)
4. [More on de Bruijn graph](https://en.wikipedia.org/wiki/De_Bruijn_graph)
5. [Simple cycle](https://en.wikipedia.org/wiki/Cycle_(graph_theory))

# Restating the problem
Given a list of DNA fragments, I need to construct the shortest possible cyclic superstring for all the given fragments.

# Solution steps
I started with this set of code that reads the DNA fragments and naively constructs a cyclic superstring by adding the two strings together if the second string is not already present in a cyclic form of the first.

```python
def add_cyclic(s, t):
    if len(s) < len(t):
        return False
    s1 = s + s
    if t in s1:
        return s
    return s + t


if __name__ == "__main__":
    file_path = "/Users/robertbryan/Downloads/rosalind_pcov_sample.txt"
    reads = []
    with open(file_path) as file:
        for line in file:
            reads.append(line.strip())
    response = reads[0]
    for i in range(1, len(reads)):
        response = add_cyclic(response, reads[i])
    print(response)
```

For the sample dataset:

```text
ATTAC
TACAG
GATTA
ACAGA
CAGAT
TTACA
AGATT
```

My first draft of code constructs the following cyclic superstring:

> ATTACTACAGTTACAAGATT    : 20 characters long

The shortest cyclic superstring for the sample dataset is:

> GATTACA     : 7 characters long

By adding this pair of nested loops to find the shortest way to concatenate two cyclic strings, I was able to bring the length of my result down to 10 characters.

```python
    s1 = rotations(s)
    t1 = rotations(t)
    max_overlap = 0
    result = ''
    for s_ in s1:
        for t_ in t1:
            if max_overlap_count(s_, t_) > max_overlap:
                result = concat_strings(s_, t_)
                max_overlap = max_overlap_count(s_, t_)
            if max_overlap_count(t_, s_) > max_overlap:
                result = concat_strings(t_, s_)
                max_overlap = max_overlap_count(t_, s_)
```

By adding a pcov function to try all possible permutations of reads, I was able to return the correct response to the sample dataset in less than 5 seconds.

```python
def pcov(reads):
    response = reads[0]
    for j in range(1, len(reads)):
        response = add_cyclic(response, reads[j])
    return response

if __name__ == "__main__":
    file_path = "/Users/robertbryan/Downloads/rosalind_pcov_sample.txt"
    reads = []
    with open(file_path) as file:
        for line in file:
            reads.append(str(line.strip()))
    min_len = sys.maxsize
    for perm in permutations(reads):
        my_len = len(pcov(perm))
        if my_len < min_len:
            min_len = my_len
            print(pcov(perm), my_len)
    print("Done.")
```

I tried my code against a challenge dataset, but I did not get a single result in the 5-minute window. The downloaded dataset was 2000 reads long. Each read was 50 characters long.

> "I'm going to need a much, much more efficient solution." -Me, now

I tried [my code from "Genome Assembly as Shortest Superstring"](https://github.com/rmbryan71/rosalind/blob/61bfecaa4aefb0cb1772545f783b586ec8995f84/solution-code/long.py) to see if it could find the shortest superstring for 2000 reads of 50 characters each _without considering the cyclic component of the strings_. My code ran for more than 5 minutes without returning a result.

I read [on Wikipedia](https://en.wikipedia.org/wiki/Shortest_common_supersequence) that the shortest common supersequence is [NP-hard](https://en.wikipedia.org/wiki/NP-hardness) and I read [here](https://www.geeksforgeeks.org/dsa/shortest-superstring-problem/) that "A solution that always finds shortest superstring takes exponential time."

I looked at [Dan Halligan's solution](https://github.com/danhalligan/rosalind.info/blob/main/rosalind/bioinformatics_stronghold/pcov.py) and realized that I'd missed two **huge** parts of the problem statement:

> "In this dataset, all k-mers from this strand of the chromosome are present..."

and also

> "... their de Bruijn graph consists of exactly one simple cycle."

which means that they can be ordered so that each string minus its first character equals the next minus its last character.

# Post-solution notes
**Challenges solved so far:** 67

**How many people solved this before me:** 849

**Most recent solve before me:** 24 days

**Time spent on challenge:** 21 hours

**Most time-consuming facet:** giving up on solving like shortest common superstring

**Solutions from others:** Everyone with a correct response took advantage of the problem constraint that all _k_-mers were present in the list of reads.

**Problem explanation:** clarifies how the constraints in the problem statement can be used to simplify solving the problem

**Closing thoughts:** I don't think I would have been able to solve this on my own no matter how long I tried. Maybe. I doubt it.