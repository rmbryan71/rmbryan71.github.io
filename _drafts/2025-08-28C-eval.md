---
layout: post
title:  "Expected Number of Restriction Sites"
date:   2025-08-28
---

[This](https://rosalind.info/problems/eval/) problem asks:

> **Given**: A positive integer n (nâ‰¤1,000,000), a DNA string s of even length at most 10, and an array A of length at most 20, containing numbers between 0 and 1.

> **Return**: An array B having the same length as A in which B[i] represents the expected number of times that s will appear as a substring of a random DNA string t of length n, where t is formed with GC-content A[i] 

<!--break-->

# References
1. [Restriction sites](https://en.wikipedia.org/wiki/Restriction_site)
2. [Recognition sequences](https://en.wikipedia.org/wiki/Recognition_sequence)
3. [Expected value from probability](https://en.wikipedia.org/wiki/Expected_value)
4. [Introduction to random strings](https://rosalind.info/problems/prob/)
5. [Indicator random variables](https://rosalind.info/glossary/indicator-random-variable/)
6. 

# Restate the problem
I need to figure out how likely it is that a random substring (s) is going to appear in a superstring n characters long if the GC-content of the superstring, n, is a value in A. 

# Solution steps
What are the chances that a single character, c, in a string with gc-content k matches a character in s?

```python
def single_prob(c, k):
    if c == 'A' or c == 'T':
        return (1 - k)/2
    else:
        return (k / 2)
```
I made good progress programming this intuitively until I ran into this roadblock:
> The round() function in Python rounds a number to the nearest integer or to a specified number of decimal places. When rounding a number that ends in .5, Python uses a method called "round half to even," which means it rounds to the nearest even number.

My first approach to always getting Python to round up when the terminating value is 5 was to import the decimal module and try:
```python
x = Decimal('0.15')
print x.quantize(Decimal('0.1'), rounding=ROUND_HALF_UP)
```

That didn't work, but I eventually succeeded in getting the correct result for the sample dataset with:
```python
with localcontext() as ctx:
    ctx.rounding = ROUND_HALF_UP
    y = Decimal(x)
    return y.quantize(Decimal('0.001'), rounding=ROUND_HALF_UP)
```

I got a correct result on my first attempt. This challenge took less than 45 minutes, with almost all of that time learning about floating point arithmatic. This was my third successful result today. I don't think I've done three during a work-day before.

I was the first person to solve this challenge in two days. 1,551 people have solved this before me. I looked up one of the people who has solved this challenge recently and reached out to them on LinkedIn. It would be nice to have contact with someone else working these challenges at the same time.

# Python concepts
Floating point arithmatic

# Bioinformatics concepts
Bacteria vs Viruses