---
layout: post
title:  "Finding a Shared Spliced Motif"
date:   2025-08-17
---

[This](https://rosalind.info/problems/lcsq/) problem asks:

> **Given**: Two DNA strings s and t

> **Return**: A longest common subsequence of s and t.

<!--break-->

# Required reading
1. [Common subsequence](https://rosalind.info/glossary/common-subsequence/)
2. [Longest common subsequence](https://en.wikipedia.org/wiki/Longest_common_subsequence)
3. [Two-dimensional arrays in Python](https://www.geeksforgeeks.org/python/python-using-2d-arrays-lists-the-right-way/)
4. [Python max function examples](https://www.w3schools.com/python/ref_func_max.asp)
5. [Python range(len())](https://pythonexamples.org/python-range-len/)
6. [Python iterables](https://stackoverflow.com/questions/19184335/is-there-a-need-for-rangelena)
7. [Python debugging](https://www.jetbrains.com/help/pycharm/part-1-debugging-python-code.html)
8. [Stack Overflow on Longest Common Subsequence](https://stackoverflow.com/questions/48651891/longest-common-subsequence-in-python)

# Restate the problem
I'm going to get two strings. I need to return the longest substring that appears in both. The characters in the substring do not need to appear consecutively in the super-stings. This is different from the longest common substring problem because the subsequences do not occupy consecutive positions in the original sequences.

# Solution steps
The Wikipedia page included [pseudocode](https://en.wikipedia.org/wiki/Pseudocode) for a two-step solution. First, a two-dimensional array is built to store the lengths of the longest common subsequences of all the subsequences of s and t.
Then, a backtrack function uses the two-dimensional array to read out the longest common subsequence.
I tried to write these myself in Python.
After some [off-by-one](https://en.wikipedia.org/wiki/Off-by-one_error) errors, I got a pair of functions that worked correctly for the sample dataset.
When I downloaded a real dataset from Project Rosalind and ran my code, I got:
```python
    C[i][j]=max(C[i][j-1], C[i-1][j])
IndexError: list index out of range
```

>list index out of range

I tried stripping whitespace and line-breaks from the inputs, but still got the same error.

>How can I get an out-of-range index with long strings but not with short strings?

I tried reversing the input strings, but that didn't make any difference.

I read up on the basics of exactly how lists and iterators work, trying to find where my code could get an index out of range.

I read the documentation on the [Python debugger](https://www.jetbrains.com/help/pycharm/part-1-debugging-python-code.html) so that I could see exactly what values my variables had at every step of execution.

I worked through a codeset posted on Stack Overflow, made a few changes to my code and got a version that provided the correct answer except for leaving off the first or last character. I couldn't tell which from my data.

When I ran the all-but-first-or-last code on a large dataset, I got:

```python
RecursionError: maximum recursion depth exceeded in comparison
```

So I tried increasing the recursion limit with:

> sys.setrecursionlimit(1500)

That allowed my program to run without error, but it was still missing one character from the solution.

After thinking about the challenge during the day at work, I made two changes:
1. I lowered the end condition for the counters in the readback function from 0 to -1.
2. I changed the lower bound on the range of the grid-building function from 1 to 0.

Those changes returned the correct result for small datasets and ran without error on large datasets, so I tried a new dataset from Project Rosalind and returned a correct result!

I'm the first person to solve this challenge today. In fact, nobody solved it yesterday either. 2,640 people have solved this before me. This challenge took me approximately 3 hours of focused work, as well as two days of thinking about the limit conditions away from the keyboard.

I unlocked the [Dynamic Programming](https://rosalind.info/badges/dynamic-programming/1/) badge with this challenge. This was my 47th successful result.

# Python concepts
Recursion

Dynamic Programming

# Bioinformatics concepts