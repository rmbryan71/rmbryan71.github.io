---
layout: post
title:  "Maximum Matchings and RNA Secondary Structures"
date:   2025-08-25
---
![Screenshot 2025-08-25 at 5.57.04â€¯PM.png](../assets/Screenshot%202025-08-25%20at%205.57.04%E2%80%AFPM.png)
Screenshot of Project Rosalind not working.

[This](https://rosalind.info/problems/mmch/) problem asks:

> **Given**: An RNA string s of length at most 100.

> **Return**: The total possible number of maximum matchings of basepair edges in the bonding graph of s.

<!--break-->

# References
1. [Graph theory on matching](https://en.wikipedia.org/wiki/Matching_(graph_theory)#Definition)
2. 

# Restate the problem
From the given RNA strand, I need to return the count of the maximum matchings possible in that bonding graph.

# Solution steps
1. I wrote a method to count the bases in the given RNA string.
2. I wrote a method to determine the length of the maximum matching available by adding the number of possible simultaneous AU pairs to the number of possible simultaneous GC pairs.
3. I wrote a method to count to total possible arrangements of maximum length by multiplying the number of all possible AU pairs by the number of all possible GC pairs.

My count_max_matchings method, shown below, returned the correct result for the sample dataset.
```python
def count_max_matchings(s):
    mydict = (count_bases(s))
    au_pairs = max(mydict['A'], mydict['U'])
    cg_pairs = max(mydict['C'], mydict['G'])
    return au_pairs * cg_pairs
```
When I tried to check my answer against a real dataset, Project Rosalind crashed! See screenshot at the top of this article.

The site was completely unreachable!

I took a few deep breaths and tried again.

The site came back up.

I got my dataset, ran my program, submitted my result and got the red "Wrong!" banner.

I thought about my code, then realized that I needed to multiply all four dictionary values together to get the total number of possible matchings, which led to the code below:
```python
def count_max_matchings(s):
    mydict = (count_bases(s))
    return mydict['A'] * mydict['U'] * mydict['C'] * mydict['G']
```
This was also incorrect. My second incorrect response unlocked the Questions section of the problem, where I read about the struggles of others.

I read the Wikipedia article on [graph theory matching](https://en.wikipedia.org/wiki/Matching_(graph_theory)#Definition), where I learned:
>Every maximum matching is maximal, but not every maximal matching is a maximum matching.

I'm not sure what that means, but I do feel confident that the A-U pairings and the C-G pairings are independent and will be multiplied by each other to get the result.

Away from the keyboard, I had the idea that the count of possible maximum matches for either half of the problem was the same as the size of the count of the more plentiful base in that half [choose](https://math.libretexts.org/Bookshelves/Combinatorics_and_Discrete_Mathematics/Elementary_Foundations%3A_An_Introduction_to_Topics_in_Discrete_Mathematics_(Sylvestre)/21%3A_Permutations/21.04%3A_Permutations_of_Subsets) the count of the least plentiful base in that half of the problem.

![choose.png](../assets/choose.png)
Explanation of P(n,k) from [math.libretexts.org](https://math.libretexts.org/Bookshelves/Combinatorics_and_Discrete_Mathematics/Elementary_Foundations%3A_An_Introduction_to_Topics_in_Discrete_Mathematics_(Sylvestre)/21%3A_Permutations/21.04%3A_Permutations_of_Subsets)

I implemented this equation in steps like this:
```python
def count_max_matchings(s):
    mydict = (count_bases(s))
    au_max = max(mydict['A'], mydict['U'])
    au_min = min(mydict['A'], mydict['U'])
    cg_max = max(mydict['C'], mydict['G'])
    cg_min = min(mydict['C'], mydict['G'])
    au_count = fact(au_max) // fact(au_max-au_min)
    cg_count = fact(cg_max) // fact(cg_max-cg_min)
    return au_count*cg_count
```

I used my own factorial function from the "[Perfect Matchings and RNA Secondary Structures](https://rosalind.info/problems/pmch/)" challenge.

```python
def fact(n):
    if n < 2:
        return 1
    else:
        return n * fact(n - 1)
```

My algorithm worked for sample datasets, and returned a correct result for the real dataset as well. The number of maximum matchings escalates quickly for larger datasets. For example, my dataset RNA string was 92 base-pairs long and the number of maximum matchings was 668326769467589022464821184293345689600000000.

Fortunately for me, Python 3 [handles arbitrary precision integers extremely well](https://www.askpython.com/python/examples/python-large-integer-handling), so working with values this big does not cause issues.

This was my 51st correct response. I was the first person to solve this challenge today. 1,878 people solved this before me. I spent about 90 minutes on this challenge, not counting time away from the keyboard when I was ruminating about it subconsciously.