---
layout: post
title:  "Catalan Numbers and RNA Secondary Structures"
date:   2025-08-22
---
![noncrossing_bonding_perfect.png](../assets/noncrossing_bonding_perfect.png)

[Figure 3 from this challenge on Project Rosalind](https://rosalind.info/media/problems/cat/noncrossing_bonding_perfect.png)

[This](https://rosalind.info/problems/cat/) problem asks:

> **Given**: An RNA string s having the same number of occurrences of 'A' as 'U' and the same number of occurrences of 'C' as 'G'.

> **Return**: The total number of noncrossing perfect matchings of basepair edges in the bonding graph of s, modulo 1,000,000.

<!--break-->

# References
1. [Noncrossing mathing](https://rosalind.info/glossary/noncrossing-matching/)
2. [Motzkin numbers](https://rosalind.info/glossary/motzkin-numbers/)
3. [More on Motzkin numbers](https://en.wikipedia.org/wiki/Motzkin_number)
4. [Catalan numbers](https://rosalind.info/glossary/catalan-numbers/)
5. [More on Catalan numbers](https://en.wikipedia.org/wiki/Catalan_number)
6. [More on Catalan numbers](https://oeis.org/A000108)

# Restate the problem
I'm going to get an RNA sequence where the count or A equals the count of U. Also, the count of C equals the count of G. I need to return the Catalan number for this sequence, which is the count of noncrossing perfect matchings, mod 1,000,000.

There's also a hint with this challenge:

> Write a function that counts Catalan numbers via dynamic programming. How can we modify this function to apply to our given problem?

# Solution steps
First, there's an equation on the Wikipedia page for Catalan numbers that gives the formula for calculating the number of noncrossing perfect matchings for each length string.

I wrote a recursive function to calculate the Catalan numbers, then tried the Catalan number for half of the length of the RNA sequence, but that gave an incorrect result.

I wrote a function to return the greater of the counts of "A" characters in the string versus the count of "G" characters in the string and tried that Catalan number, but that was also incorrect.

Two incorrect responses unlocked the "Questions" area of Project Rosalind for this challenge.

After reading the questions and answers there, I tried:

> print(cat(2*maxchar(s))%1000000)

That response was also incorrect.

One of the hints in the Questions section is:

> My answer for  CGGCUGCUACGCGUAAGCCGGCUGCUACGCGUAAGC is 736

So I tried every possible combination of adding, subtracting, multiplying, and dividing Catalan numbers less than 50, but never had a result of 736, and 736 is not a Catalan number itself, so that seemed to rule out the naive assumption that the correct result is a simple operation of two Catalan numbers.

I re-read the problem slowly several times and spent a lot of time looking at figure 3, shown above.

I realized that the order of the nodes makes a difference in how many noncrossing perfect matchings are possible.

Figure 3 shows that the number of noncrossing perfect matchings for 'UAGCGUGAUCAC' is 2.

I wrote a function to list all the possible pairings for a string.

I wrote a function to take all the possible pairings and return only the complete ones.

I wrote a function to take all the complete pairings and return only the non-crossing ones.

This combination of functions returned the correct result for small datasets, but took far too long on real datasets.

The part that takes too long is considering all the possible pairings and returning only the complete ones.

I worked for a day and a half on a quick way to generate a list of complete pairings from a list of all pairings.
 
I decided to start looking at posted answers for clues. I checked:
1. [cdeterman's answer](https://github.com/cdeterman/Rosalind/blob/master/033_CAT/033_CAT.py): I studied this solution in depth. They use a global cache and a recursive function to identify a count of noncrossing complete matches without specifically listing them all.
2. [This reddit article](https://www.reddit.com/r/bioinformatics/comments/k87ckl/catalan_numbers_and_rna_secondary_structures_help/): included one helpful text hint a link to the Nussinov algorithm.
3. [Nussinov algorithm](https://en.wikipedia.org/wiki/Nussinov_algorithm): this approach includes building a martix of scores for optimal foldings of subsequences. Then there is a traceback function to read the back all the possible paired bases.
4. [RNA pseudoknots](https://en.wikipedia.org/wiki/Pseudoknot): I read this because pseudoknots are mentioned in the challenge, but I don't think I learned anything directly applicable to a solution.
5. [Ruth Nussinov](https://en.wikipedia.org/wiki/Ruth_Nussinov): proposed the Nussinov algorithm in 1978.
6. [Zong Hui's answer](https://github.com/zonghui0228/rosalind-solutions/blob/master/code/rosalind_cat.py): Their code also calculates the number of noncrossing complete matches without calculating each one in full.
7. [Kaiwant0112006's answer](https://kaiwang0112006.github.io/rosalind_solve/code/CatalanNumbersandRNASecondaryStructures/CatalanNumbersandRNASecondaryStructures.html): I learned a lot from reading this code very carefully. Specifically, I figured out how to use [memoization](https://en.wikipedia.org/wiki/Memoization) with [recursion](https://en.wikipedia.org/wiki/Recursion) to solve this challenge. What I was missing is that a global dictionary lives outside the recursion loop and gets built up by successful loops through the recursion.

I removed all of my code that attempted to count the number of noncrossing complete matches by specifically listing each one.

I used an approach similar to Kaiwant0112006 which solved the first dataset from Project Rosalind correctly.
I was the first person to solve this challenge on August 25, 2025. Someone solved it yesterday. 1,633 people have solved this before me. This was my 50th correct solution.

This challenge took a long time to solve, over 30 hours of direct working time, and eventually I got the idea that solved the problem by looking at someone else's code.






# Python concepts

# Bioinformatics concepts