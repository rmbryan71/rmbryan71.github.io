---
layout: post
title:  "Introduction to Alternative Splicing"
date:   2025-08-28
---

[This](https://rosalind.info/problems/aspc/) problem asks:

> **Given**: Positive integers n and m with 0≤m≤n≤2000.

> **Return**: The sum of combinations C(n,k) for all k satisfying m≤k≤n, modulo 1,000,000. 

<!--break-->

# References
1. [Combinations](https://en.wikipedia.org/wiki/Combination)
2. [Counting subsets](https://rosalind.info/problems/sset/)

# Restate the problem
I'm going to get two integers less than 2000. I need to find the sum of all the combination equations C(n, k) where k is between or equal to the two integers I get. This is going to be an extremely large number, so I'm need to return the answer modulo 1,000,000.

# Solution steps
First, I used the formula from Wikipedia to count the number of possible combinations:
```python
def comb(n, k):
    return (fact(n) // fact(k)*fact(n - k))
```

but that returned a value much higher than the correct response for the sample dataset.

I installed the math library and used math.comb(n, k) to calculate the number of combinations and got the correct result for the sample dataset.

For some reason, I wasn't content with the correct answer using the math library, so I continued troubleshooting my own equation until I found that wrapping the denominator in parentheses fixed my equation.
```python
def comb(n, k):
    return fact(n) // (fact(k)*fact(n - k))
```

Compare this code with the incorrect version above.

When I ran both my version and the math library version against Project Rosalind-sized datasets, my version reached the recursion limit trying to figure out the factorial for 1,689, while the math library version delivered the correct response on the first try.

This was my 53rd correct response. 1,911 people solved this before me. Nobody had solved this challenge for two days. 

# Python concepts
Recursion limits

# Bioinformatics concepts