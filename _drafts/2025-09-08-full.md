---
layout: post
title:  "Inferring Peptide from Full Spectrum"
date:   2025-07-18
---

[This](https://rosalind.info/problems/full/) problem asks:

> **Given**: A list _L_ containing 2*n*+3 positive real numbers (_n_â‰¤100). The first number in _L_ is the parent mass of a peptide _P_, and all other numbers represent the masses of some b-ions and y-ions of _P_ (in no particular order). You may assume that if the mass of a b-ion is present, then so is that of its complementary y-ion, and vice-versa.

> **Return**: A protein string _t_ of length _n_ for which there exist two positive real numbers _w1_ and _w2_ such that for every prefix _p_ and suffix _s_ of _t_, each of _w(p)+w1_ and _w(s)+w2_ is equal to an element of _L_. (In other words, there exists a protein string whose _t_-prefix and _t_-suffix weights correspond to the non-parent mass values of _L_.)

<!--break-->

# References
1. Review of [Inferring Protein from Spectrum](https://rosalind.info/problems/spec/)
2. [b-ion](https://rosalind.info/glossary/b-ion/)
3. [N-terminus](https://rosalind.info/glossary/n-terminus/)
4. [y-ion](https://rosalind.info/glossary/y-ion/)
5. [C-terminus](https://rosalind.info/glossary/c-terminus/)
6. [Parent mass](https://rosalind.info/glossary/parent-mass/)
7. [t-prefix](https://rosalind.info/glossary/t-prefix/)
8. [t-suffix](https://rosalind.info/glossary/t-suffix/)
9. 

# Restating the problem
For reference, this is the entire problem statement from Project Rosalind:

> Say that we have a string _s_ containing _t_ as an internal substring, so that there exist nonempty substrings _s1_ and _s2_ of _s_ such that _s_ can be written as _s1ts2_. A _t_-prefix contains all of _s1_ and none of _s2_; likewise, a _t_-suffix contains all of _s2_ and none of _s1_.

From the list of given weights, I need to calculate the protein string that corresponds to the internal substring _t_.

# Solution steps
First, I started with my [code from the Inferring Protein from Spectrum challenge](https://github.com/rmbryan71/rosalind/blob/main/solution-code/spec.py) because they had a lot in common.

When I was rereading the problem statement and looking at the list of weights, I noticed that the two smallest ion weights added up to the parent weight. I made the temporary assumption that those two values are the weights of _s1_ and _s2_, so I assigned them to variables and removed them from the list.

At that point, I had a list of length _2n_ because the problem told me the given list was 2*n* + 3 numbers long and I have removed 3 values.

Then, I focused on how this assumption applies to the remaining values:

> You may assume that if the mass of a b-ion is present, then so is that of its complementary y-ion, and vice-versa.

I wrote this test to confirm that every weight in _L_ has a corresponding weight where the two add up to the parent weight. In a sorted list _L_, this confirms the assumption:
```python
while L:
    print(L.pop(0) + L.pop(-1))
```

For each of these weight pairs, I suspected that their difference would correspond to a protein weight, so I wrote the following code:

```python
while L:
    result.append(round((L.pop(-1) - L.pop(0)), 2))
for j in result:
    print(list(rounded_dict.keys())[list(rounded_dict.values()).index(j)], end='')
```

This returned an error because the values didn't match keys in the dictionary.

Experimenting further, I found that for each pair of weights, the lesser value - _s1_ equalled _s2_ - the greater value, and some, but not all, of those differences appeared in the protein weight table.

I tried this approach to find all the differences between all combinations of weights:

```python
for i in range(0, len(L)):
    for j in range(0, len(L)):
        val = round(L[i] - L[j], 2)
        if val in rounded_dict.values():
            result.append(val)
```

This returns all the correct proteins, but many copies of them and other incorrect proteins as well, so that's not progress.

I went back to rereading this line in the problem statement:

> A protein string _t_ of length _n_ for which there exist two positive real numbers _w1_ and _w2_ such that for every prefix _p_ and suffix _s_ of _t_, each of _w(p)+w1_ and _w(s)+w2_ is equal to an element of _L_.

What does this mean?

Are _w1_ and _w2_ in the list of given weights? They must be. That has to be why we get 2n + 3 values. One is the parent mass and the other two are _w1_ and _w2_. I tried taking the greatest and least weights as _w1_ and _w2_ with this code:

```python
    parent_mass = L.pop(0)
    L = sorted(L)
    w1 = L.pop(0)
    w2 = L.pop(-1)
    print(parent_mass, w1, w2)
    print(L)
    result = []
    while L:
        prefix = L.pop(0)
        suffix = L.pop(-1)
        print(prefix - w1, w2 - suffix)
```

Again, this generated some matches to the protein weight table, but there were incorrect proteins in the result and not all the correct proteins were listed.

I tried the two central weights in the sorted list as _w1_ and _w2_ with similar results. Some matches to the protein table, but with incorrect proteins and not all the correct proteins.

This code produces interesting results:
```python
    for i in range(0, len(L)//2):
        w1 = L[i]
        w2 = L[len(L)-1-i]
        sum = w1 + w2
        print(i, w1, w2, sum)
```

the results:
```text
0 610.391039105 1377.8200091 1988.2110482050002
1 738.485999105 1249.7250491 1988.211048205
2 766.492149105 1221.7188991 1988.211048205
3 863.544909105 1124.6661391 1988.211048205
4 867.528589105 1120.6824591 1988.211048205
5 992.587499105 995.623549105 1988.2110482100002
```

There are 6 pairs of weights where each pair adds up to the parent weight.

Not 5. One of these pairs has to be _w1_ and _w2_, right?

# Python concepts

# Bioinformatics concepts

# Post-solution notes
**Challenges solved so far:** 

**How many people solved this before me:** 

**Most recent solve before me:** 

**Time spent on challenge:** 

**Most time-consuming facet:** 

**Questions from others:** 

**Solutions from others:**

**Problem explanation:** 

**Accomplishments and badges:** 

**Closing thoughts:** 