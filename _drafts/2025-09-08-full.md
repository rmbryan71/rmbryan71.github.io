---
layout: post
title:  "Inferring Peptide from Full Spectrum"
date:   2025-07-18
---

[This](https://rosalind.info/problems/full/) problem asks:

> **Given**: A list _L_ containing 2*n*+3 positive real numbers (_n_â‰¤100). The first number in _L_ is the parent mass of a peptide _P_, and all other numbers represent the masses of some b-ions and y-ions of _P_ (in no particular order). You may assume that if the mass of a b-ion is present, then so is that of its complementary y-ion, and vice-versa.

> **Return**: A protein string _t_ of length _n_ for which there exist two positive real numbers _w1_ and _w2_ such that for every prefix _p_ and suffix _s_ of _t_, each of _w(p)+w1_ and _w(s)+w2_ is equal to an element of _L_. (In other words, there exists a protein string whose _t_-prefix and _t_-suffix weights correspond to the non-parent mass values of _L_.)

<!--break-->

# References
1. Review of [Inferring Protein from Spectrum](https://rosalind.info/problems/spec/)
2. [b-ion](https://rosalind.info/glossary/b-ion/)
3. [N-terminus](https://rosalind.info/glossary/n-terminus/)
4. [y-ion](https://rosalind.info/glossary/y-ion/)
5. [C-terminus](https://rosalind.info/glossary/c-terminus/)
6. [Parent mass](https://rosalind.info/glossary/parent-mass/)
7. [t-prefix](https://rosalind.info/glossary/t-prefix/)
8. [t-suffix](https://rosalind.info/glossary/t-suffix/)
9. 

# Restating the problem
For reference, this is the entire problem statement from Project Rosalind:

> Say that we have a string _s_ containing _t_ as an internal substring, so that there exist nonempty substrings _s1_ and _s2_ of _s_ such that _s_ can be written as _s1ts2_. A _t_-prefix contains all of _s1_ and none of _s2_; likewise, a _t_-suffix contains all of _s2_ and none of _s1_.

From the list of given weights, I need to calculate the protein string that corresponds to the internal substring _t_.

# Solution steps
First, I started with my [code from the Inferring Protein from Spectrum challenge](https://github.com/rmbryan71/rosalind/blob/main/solution-code/spec.py) because they had a lot in common.

When I was rereading the problem statement and looking at the list of weights, I noticed that the two smallest ion weights added up to the parent weight. I made the temporary assumption that those two values are the weights of _s1_ and _s2_, so I assigned them to variables and removed them from the list.

At that point, I had a list of length _2n_ because the problem told me the given list was 2*n* + 3 numbers long and I have removed 3 values.

Then, I focused on how this assumption applies to the remaining values:

> You may assume that if the mass of a b-ion is present, then so is that of its complementary y-ion, and vice-versa.

I wrote this test to confirm that every weight in _L_ has a corresponding weight where the two add up to the parent weight. In a sorted list _L_, this confirms the assumption:
```python
while L:
    print(L.pop(0) + L.pop(-1))
```

For each of these weight pairs, I suspected that their difference would correspond to a protein weight, so I wrote the following code:

```python
while L:
    result.append(round((L.pop(-1) - L.pop(0)), 2))
for j in result:
    print(list(rounded_dict.keys())[list(rounded_dict.values()).index(j)], end='')
```

This returned an error because the values didn't match keys in the dictionary.

Experimenting further, I found that for each pair of weights, the lesser value - _s1_ equalled _s2_ - the greater value, and some, but not all, of those differences appeared in the protein weight table.



# Python concepts

# Bioinformatics concepts

# Post-solution notes
**Challenges solved so far:** 

**How many people solved this before me:** 

**Most recent solve before me:** 

**Time spent on challenge:** 

**Most time-consuming facet:** 

**Questions from others:** 

**Solutions from others:**

**Problem explanation:** 

**Accomplishments and badges:** 

**Closing thoughts:** 